// this file is not the one generated by ffiGen.
// ffiGen will generate [flutter_soloud_bindings_ffi_TMP.dart]
// from [ffi_gen_tmp.h] file. Read notes in the latter
// ignore_for_file: avoid_positional_boolean_parameters, require_trailing_commas

import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart';

/// Possible player errors
enum PlayerErrors {
  /// No error
  noError,

  /// Some parameter is invalid
  invalidParameter,

  /// File not found
  fileNotFound,

  /// File found, but could not be loaded
  fileLoadFailed,

  /// The sound file has already been loaded
  fileAlreadyLoaded,

  /// DLL not found, or wrong DLL
  dllNotFound,

  /// Out of memory
  outOfMemory,

  /// Feature not implemented
  notImplemented,

  /// Other error
  unknownError,

  /// null pointer. Could happens when passing a non initialized
  /// pointer (with calloc()) to retrieve FFT or wave data
  nullPointer,

  /// The sound with specified hash is not found
  soundHashNotFound,

  /// Player not initialized
  backendNotInited,

  /// Audio isolate already started
  isolateAlreadyStarted,

  /// Audio isolate not yet started
  isolateNotStarted,

  /// Engine not yet started
  engineNotInited,

  /// Filter not found
  filterNotFound,
}

/// Wave forms
enum WaveForm {
  /// Raw, harsh square wave
  square,

  /// Raw, harsh saw wave
  saw,

  /// Sine wave
  sin,

  /// Triangle wave
  triangle,

  /// Bounce, i.e, abs(sin())
  bounce,

  /// Quater sine wave, rest of period quiet
  jaws,

  /// Half sine wave, rest of period quiet
  humps,

  /// "Fourier" square wave; less noisy
  fSquare,

  /// "Fourier" saw wave; less noisy
  fSaw,
}

/// FFI bindings to SoLoud
class FlutterSoLoudFfi {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  // ignore: sort_constructors_first
  FlutterSoLoudFfi(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  // ignore: sort_constructors_first
  FlutterSoLoudFfi.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// FOR NOW THIS CALLBACK IS NOT USED
  ///
//   /// Since using the callback passed to [setPlayEndedCallback] will throw
//   /// ```Error: fromFunction expects a static function as parameter.
//   /// dart:ffi only supports calling static Dart functions from native code.
//   /// Closures and tear-offs are not supported because
//   /// they can capture context.```
//   static void Function(int)? _userPlayEndedCallback;
//   /// here the user callback given to [setPlayEndedCallback] will be temporarly
// /// saved into [_userPlayEndedCallback]. The [_playEndedCallback] will instead
// /// passed to C side to be called, which then call the user callback.
//   static void _playEndedCallback(int handle) {
//     if (_userPlayEndedCallback != null) {
//       // ignore: prefer_null_aware_method_calls
//       _userPlayEndedCallback!(handle);
//     }
//   }
//   /// @brief Set a dart function to call when the sound with [handle] handle ends
//   /// @param callback this is the dart function that will be called
//   ///     when the sound ends to play.
//   ///     Must be global or a static class member:
//   ///     ```@pragma('vm:entry-point')
//   ///        void playEndedCallback(int handle) {
//   ///             // here the sound with [handle] has ended.
//   ///             // you can play again
//   ///             soLoudController.soLoudFFI.play(handle);
//   ///             // or dispose it
//   ///             soLoudController.soLoudFFI.stop(handle);
//   ///        }
//   ///     ```
//   /// @param handle the handle to the sound
//   /// @return callback this is the dart function that will be called
//   ///         when the sound ends to play
//   /// @return true if success;
//   /// https://github.com/dart-lang/sdk/issues/37022
//   /// PS: NOT USED, maybe in another time
//   bool setPlayEndedCallback(
//     void Function(int) callback,
//     int handle,
//   ) {

//     _userPlayEndedCallback = callback;
//     final ret = _setPlayEndedCallback(
//       ffi.Pointer.fromFunction(_playEndedCallback),
//       handle,
//     );

//     return ret == 1 ? true : false;
//   }

//   late final _setPlayEndedCallbackPtr = _lookup<
//       ffi.NativeFunction<
//           ffi.Int Function(
//               ffi.Pointer<
//                   ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>,
//               ffi.UnsignedInt)>>('setPlayEndedCallback');
//   late final _setPlayEndedCallback = _setPlayEndedCallbackPtr.asFunction<
//       int Function(
//         ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>,
//         int)>();

  /// Initialize the player. Must be called before any other player functions
  ///
  /// Returns [PlayerErrors.noError] if success
  PlayerErrors initEngine() {
    return PlayerErrors.values[_initEngine()];
  }

  late final _initEnginePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('initEngine');
  late final _initEngine = _initEnginePtr.asFunction<int Function()>();

  /// Must be called when there is no more need of the player
  /// or when closing the app
  ///
  void dispose() {
    return _dispose();
  }

  late final _disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('dispose');
  late final _dispose = _disposePtr.asFunction<void Function()>();

  /// Load a new sound to be played once or multiple times later
  ///
  /// [completeFileName] the complete file path
  /// soundHash return hash of the sound
  /// Returns [PlayerErrors.noError] if success
  ({PlayerErrors error, int soundHash}) loadFile(String completeFileName) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> h =
        calloc(ffi.sizeOf<ffi.UnsignedInt>());
    final e = _loadFile(
      completeFileName.toNativeUtf8().cast<ffi.Char>(),
      h,
    );
    final ret = (error: PlayerErrors.values[e], soundHash: h.value);
    calloc.free(h);
    return ret;
  }

  late final _loadFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.UnsignedInt>,
          )>>('loadFile');
  late final _loadFile = _loadFilePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Load a new waveform to be played once or multiple times later
  ///
  /// [waveform]
  /// [superWave]
  /// [scale]
  /// [detune]
  /// soundHash return hash of the sound
  /// Returns [PlayerErrors.noError] if success
  ({PlayerErrors error, int soundHash}) loadWaveform(
    WaveForm waveform,
    bool superWave,
    double scale,
    double detune,
  ) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> h =
        calloc(ffi.sizeOf<ffi.UnsignedInt>());
    final e = _loadWaveform(
      waveform.index,
      superWave ? 1 : 0,
      scale,
      detune,
      h,
    );
    final ret = (error: PlayerErrors.values[e], soundHash: h.value);
    calloc.free(h);
    return ret;
  }

  late final _loadWaveformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int, ffi.Int, ffi.Float, ffi.Float,
              ffi.Pointer<ffi.UnsignedInt>)>>('loadWaveform');
  late final _loadWaveform = _loadWaveformPtr.asFunction<
      int Function(int, int, double, double, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Set the scale of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newScale]
  void setWaveformScale(int hash, double newScale) {
    return _setWaveformScale(hash, newScale);
  }

  late final _setWaveformScalePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setWaveformScale');
  late final _setWaveformScale =
      _setWaveformScalePtr.asFunction<void Function(int, double)>();

  /// Set the detune of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newDetune]
  void setWaveformDetune(int hash, double newDetune) {
    return _setWaveformDetune(hash, newDetune);
  }

  late final _setWaveformDetunePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setWaveformDetune');
  late final _setWaveformDetune =
      _setWaveformDetunePtr.asFunction<void Function(int, double)>();

  /// Set a new frequency of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newFreq]
  void setWaveformFreq(int hash, double newFreq) {
    return _setWaveformFreq(hash, newFreq);
  }

  late final _setWaveformFreqPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setWaveformFreq');
  late final _setWaveformFreq =
      _setWaveformFreqPtr.asFunction<void Function(int, double)>();

  /// Set a new frequence of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [superwave]
  void setWaveformSuperWave(int hash, int superwave) {
    return _setSuperWave(hash, superwave);
  }

  late final _setSuperWavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setSuperWave');
  late final _setSuperWave =
      _setSuperWavePtr.asFunction<void Function(int, int)>();

  /// Set a new wave form of an already loaded waveform identified by [hash]
  ///
  /// [hash] the unique sound hash of a waveform sound
  /// [newWaveform]  WAVE_SQUARE = 0,
  /// WAVE_SAW,
  /// WAVE_SIN,
  /// WAVE_TRIANGLE,
  /// WAVE_BOUNCE,
  /// WAVE_JAWS,
  /// WAVE_HUMPS,
  /// WAVE_FSQUARE,
  /// WAVE_FSAW
  void setWaveform(int hash, WaveForm newWaveform) {
    return _setWaveform(hash, newWaveform.index);
  }

  late final _setWaveformPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setWaveform');
  late final _setWaveform =
      _setWaveformPtr.asFunction<void Function(int, int)>();

  /// Speech the text given
  ///
  /// [textToSpeech]
  /// Returns PlayerErrors.noError if success and handle sound identifier
  // TODO(me): add other T2S parameters
  ({PlayerErrors error, int handle}) speechText(String textToSpeech) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.UnsignedInt> handle = calloc();
    final e = _speechText(
      textToSpeech.toNativeUtf8().cast<ffi.Char>(),
      handle,
    );
    final ret = (error: PlayerErrors.values[e], handle: handle.value);
    calloc.free(handle);
    return ret;
  }

  late final _speechTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.UnsignedInt>,
          )>>('speechText');
  late final _speechText = _speechTextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// Switch pause state of an already loaded sound identified by [handle]
  ///
  /// [handle] the sound handle
  void pauseSwitch(int handle) {
    return _pauseSwitch(handle);
  }

  late final _pauseSwitchPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
    'pauseSwitch',
  );
  late final _pauseSwitch = _pauseSwitchPtr.asFunction<void Function(int)>();

  /// Pause or unpause already loaded sound identified by [handle]
  ///
  /// [handle] the sound handle
  /// [pause] the sound handle
  void setPause(int handle, int pause) {
    return _setPause(handle, pause);
  }

  late final _setPausePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
          'setPause');
  late final _setPause = _setPausePtr.asFunction<void Function(int, int)>();

  /// Gets the pause state
  ///
  /// [handle] the sound handle
  /// Return true if paused
  bool getPause(int handle) {
    return _getPause(handle) == 1;
  }

  late final _getPausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
    'getPause',
  );
  late final _getPause = _getPausePtr.asFunction<int Function(int)>();

  /// Set a sound's relative play speed.
  /// Setting the value to 0 will cause undefined behavior, likely a crash.
  /// Change the relative play speed of a sample. This changes the effective
  /// sample rate while leaving the base sample rate alone.
  ///
  /// Note that playing a sound at a higher sample rate will require SoLoud
  /// to request more samples from the sound source, which will require more
  /// memory and more processing power. Playing at a slower sample
  /// rate is cheaper.
  ///
  /// [handle] the sound handle
  /// [speed] the new speed
  void setRelativePlaySpeed(int handle, double speed) {
    return _setRelativePlaySpeed(handle, speed);
  }

  late final _setRelativePlaySpeedPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
      'setRelativePlaySpeed');
  late final _setRelativePlaySpeed =
      _setRelativePlaySpeedPtr.asFunction<void Function(int, double)>();

  /// Return the current play speed.
  ///
  /// [handle] the sound handle
  double getRelativePlaySpeed(int handle) {
    return _getRelativePlaySpeed(handle);
  }

  late final _getRelativePlaySpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.UnsignedInt)>>(
          'getRelativePlaySpeed');
  late final _getRelativePlaySpeed =
      _getRelativePlaySpeedPtr.asFunction<double Function(int)>();

  /// Play already loaded sound identified by [soundHash].
  ///
  /// [soundHash] the unique sound hash of a sound
  /// [volume] 1.0f full volume
  /// [pan] 0.0f centered
  /// [paused] 0 not pause
  /// Return the handle of the sound, 0 if error
  int play(
    int soundHash, {
    double volume = 1,
    double pan = 0,
    bool paused = false,
  }) {
    return _play(soundHash, volume, pan, paused ? 1 : 0);
  }

  late final _playPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Int,
          )>>('play');
  late final _play =
      _playPtr.asFunction<int Function(int, double, double, int)>();

  /// Stop already loaded sound identified by [handle] and clear it.
  ///
  /// [handle]
  void stop(int handle) {
    return _stop(handle);
  }

  late final _stopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('stop');
  late final _stop = _stopPtr.asFunction<void Function(int)>();

  /// Stop all handles of the already loaded sound identified
  /// by [soundHash] and dispose it.
  ///
  /// [soundHash]
  void disposeSound(int soundHash) {
    return _stopSound(soundHash);
  }

  late final _stopSoundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
    'disposeSound',
  );
  late final _stopSound = _stopSoundPtr.asFunction<void Function(int)>();

  /// Dispose all sounds already loaded
  void disposeAllSound() {
    return _disposeAllSound();
  }

  late final _disposeAllSoundPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('disposeAllSound');
  late final _disposeAllSound =
      _disposeAllSoundPtr.asFunction<void Function()>();

  /// This function can be used to set a sample to play on repeat,
  /// instead of just playing once
  ///
  /// [handle]
  /// [enable]
  void setLooping(int handle, bool enable) {
    return _setLooping(handle, enable ? 1 : 0);
  }

  late final _setLoopingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Int)>>(
    'setLooping',
  );
  late final _setLooping = _setLoopingPtr.asFunction<void Function(int, int)>();

  /// Enable or disable visualization
  ///
  /// [enabled] enable or disable it
  void setVisualizationEnabled(bool enabled) {
    return _setVisualizationEnabled(
      enabled ? 1 : 0,
    );
  }

  late final _setVisualizationEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
    'setVisualizationEnabled',
  );
  late final _setVisualizationEnabled =
      _setVisualizationEnabledPtr.asFunction<void Function(int)>();

  /// Returns valid data only if VisualizationEnabled is true
  ///
  /// [fft]
  /// Return a 256 float array containing FFT data.
  void getFft(ffi.Pointer<ffi.Float> fft) {
    return _getFft(fft);
  }

  late final _getFftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
    'getFft',
  );
  late final _getFft =
      _getFftPtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Returns valid data only if VisualizationEnabled is true
  ///
  /// fft
  /// Return a 256 float array containing wave data.
  void getWave(ffi.Pointer<ffi.Float> wave) {
    return _getWave(wave);
  }

  late final _getWavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
    'getWave',
  );
  late final _getWave =
      _getWavePtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Smooth FFT data.
  /// When new data is read and the values are decreasing, the new value will be
  /// decreased with an amplitude between the old and the new value.
  /// This will result on a less shaky visualization.
  ///
  /// [smooth] must be in the [0.0 ~ 1.0] range.
  /// 0 = no smooth
  /// 1 = full smooth
  /// the new value is calculated with:
  /// newFreq = smooth * oldFreq + (1 - smooth) * newFreq
  void setFftSmoothing(double smooth) {
    return _setFftSmoothing(smooth);
  }

  late final _setFftSmoothingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
    'setFftSmoothing',
  );
  late final _setFftSmoothing =
      _setFftSmoothingPtr.asFunction<void Function(double)>();

  /// Return in [samples] a 512 float array.
  /// The first 256 floats represent the FFT frequencies data [0.0~1.0].
  /// The other 256 floats represent the wave data (amplitude) [-1.0~1.0].
  ///
  /// [samples] should be allocated and freed in dart side
  void getAudioTexture(ffi.Pointer<ffi.Float> samples) {
    return _getAudioTexture(samples);
  }

  late final _getAudioTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
    'getAudioTexture',
  );
  late final _getAudioTexture =
      _getAudioTexturePtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Return a floats matrix of 256x512
  /// Every row are composed of 256 FFT values plus 256 of wave data
  /// Every time is called, a new row is stored in the
  /// first row and all the previous rows are shifted
  /// up (the last one will be lost).
  ///
  /// [samples]
  PlayerErrors getAudioTexture2D(ffi.Pointer<ffi.Pointer<ffi.Float>> samples) {
    if (samples == ffi.nullptr) return PlayerErrors.nullPointer;
    final ret = _getAudioTexture2D(samples);
    return PlayerErrors.values[ret];
  }

  late final _getAudioTexture2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Pointer<ffi.Float>>,
          )>>('getAudioTexture2D');
  late final _getAudioTexture2D = _getAudioTexture2DPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Float>>)>();

  /// Get the sound length in seconds
  ///
  /// [soundHash] the sound hash
  /// Returns sound length in seconds
  double getLength(int soundHash) {
    return _getLength(soundHash);
  }

  late final _getLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
    'getLength',
  );
  late final _getLength = _getLengthPtr.asFunction<double Function(int)>();

  /// Seek playing in [time] seconds
  /// [time]
  /// [handle] the sound handle
  /// Returns [PlayerErrors.noError] if success
  int seek(int handle, double time) {
    return _seek(handle, time);
  }

  late final _seekPtr = _lookup<
      ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
    'seek',
  );
  late final _seek = _seekPtr.asFunction<int Function(int, double)>();

  /// Get current sound position  in seconds
  ///
  /// [handle] the sound handle
  /// Returns time in seconds
  double getPosition(int handle) {
    return _getPosition(handle);
  }

  late final _getPositionPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
    'getPosition',
  );
  late final _getPosition = _getPositionPtr.asFunction<double Function(int)>();

  /// Get current Global volume
  ///
  /// Returns the volume
  double getGlobalVolume() {
    return _getGlobalVolume();
  }

  late final _getGlobalVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('getGlobalVolume');
  late final _getGlobalVolume =
      _getGlobalVolumePtr.asFunction<double Function()>();

  /// Set current Global volume
  ///
  /// Returns [PlayerErrors.noError] if success
  int setGlobalVolume(double volume) {
    return _setGlobalVolume(volume);
  }

  late final _setGlobalVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>(
          'setGlobalVolume');
  late final _setGlobalVolume =
      _setGlobalVolumePtr.asFunction<int Function(double)>();

  /// Get current [handle] volume
  ///
  /// Returns the volume
  double getVolume(int handle) {
    return _getVolume(handle);
  }

  late final _getVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
          'getVolume');
  late final _getVolume = _getVolumePtr.asFunction<double Function(int)>();

  /// Set current [handle] volume
  ///
  /// Returns [PlayerErrors.noError] if success
  int setVolume(int handle, double volume) {
    return _setVolume(handle, volume);
  }

  late final _setVolumePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
      'setVolume');
  late final _setVolume = _setVolumePtr.asFunction<int Function(int, double)>();

  /// Check if a handle is still valid.
  ///
  /// [handle] handle to check
  /// Return true if it still exists
  bool getIsValidVoiceHandle(int handle) {
    return _getIsValidVoiceHandle(handle) == 1;
  }

  late final _getIsValidVoiceHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
    'getIsValidVoiceHandle',
  );
  late final _getIsValidVoiceHandle =
      _getIsValidVoiceHandlePtr.asFunction<int Function(int)>();

  /////////////////////////////////////////
  /// faders
  /////////////////////////////////////////

  /// Smoothly change the global volume over specified time.
  ///
  int fadeGlobalVolume(double to, double time) {
    return _fadeGlobalVolume(to, time);
  }

  late final _fadeGlobalVolumePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float, ffi.Float)>>(
          'fadeGlobalVolume');
  late final _fadeGlobalVolume =
      _fadeGlobalVolumePtr.asFunction<int Function(double, double)>();

  /// Smoothly change a channel's volume over specified time.
  ///
  int fadeVolume(int handle, double to, double time) {
    return _fadeVolume(handle, to, time);
  }

  late final _fadeVolumePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.UnsignedInt, ffi.Float, ffi.Float)>>('fadeVolume');
  late final _fadeVolume =
      _fadeVolumePtr.asFunction<int Function(int, double, double)>();

  /// Smoothly change a channel's pan setting over specified time.
  ///
  int fadePan(int handle, double to, double time) {
    return _fadePan(handle, to, time);
  }

  late final _fadePanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.UnsignedInt, ffi.Float, ffi.Float)>>('fadePan');
  late final _fadePan =
      _fadePanPtr.asFunction<int Function(int, double, double)>();

  /// Smoothly change a channel's relative play speed over specified time.
  ///
  int fadeRelativePlaySpeed(int handle, double to, double time) {
    return _fadeRelativePlaySpeed(handle, to, time);
  }

  late final _fadeRelativePlaySpeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.UnsignedInt, ffi.Float, ffi.Float)>>('fadeRelativePlaySpeed');
  late final _fadeRelativePlaySpeed =
      _fadeRelativePlaySpeedPtr.asFunction<int Function(int, double, double)>();

  /// After specified time, pause the channel.
  ///
  int schedulePause(int handle, double time) {
    return _schedulePause(handle, time);
  }

  late final _schedulePausePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
      'schedulePause');
  late final _schedulePause =
      _schedulePausePtr.asFunction<int Function(int, double)>();

  /// After specified time, stop the channel.
  ///
  int scheduleStop(int handle, double time) {
    return _scheduleStop(handle, time);
  }

  late final _scheduleStopPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.UnsignedInt, ffi.Float)>>(
      'scheduleStop');
  late final _scheduleStop =
      _scheduleStopPtr.asFunction<int Function(int, double)>();

  /// Set fader to oscillate the volume at specified frequency.
  ///
  int oscillateVolume(int handle, double from, double to, double time) {
    return _oscillateVolume(handle, from, to, time);
  }

  late final _oscillateVolumePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float,
              ffi.Float)>>('oscillateVolume');
  late final _oscillateVolume = _oscillateVolumePtr
      .asFunction<int Function(int, double, double, double)>();

  /// Set fader to oscillate the panning at specified frequency.
  ///
  int oscillatePan(int handle, double from, double to, double time) {
    return _oscillatePan(handle, from, to, time);
  }

  late final _oscillatePanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float,
              ffi.Float)>>('oscillatePan');
  late final _oscillatePan =
      _oscillatePanPtr.asFunction<int Function(int, double, double, double)>();

  /// Set fader to oscillate the relative play speed at specified frequency.
  ///
  int oscillateRelativePlaySpeed(
      int handle, double from, double to, double time) {
    return _oscillateRelativePlaySpeed(handle, from, to, time);
  }

  late final _oscillateRelativePlaySpeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.UnsignedInt, ffi.Float, ffi.Float,
              ffi.Float)>>('oscillateRelativePlaySpeed');
  late final _oscillateRelativePlaySpeed = _oscillateRelativePlaySpeedPtr
      .asFunction<int Function(int, double, double, double)>();

  /// Set fader to oscillate the global volume at specified frequency.
  ///
  int oscillateGlobalVolume(double from, double to, double time) {
    return _oscillateGlobalVolume(from, to, time);
  }

  late final _oscillateGlobalVolumePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Float, ffi.Float, ffi.Float)>>(
      'oscillateGlobalVolume');
  late final _oscillateGlobalVolume = _oscillateGlobalVolumePtr
      .asFunction<int Function(double, double, double)>();

  /////////////////////////////////////////
  /// Filters
  /////////////////////////////////////////

  /// Check if the given filter is active or not.
  ///
  /// [filterType] filter to check
  /// Returns [PlayerErrors.noError] if no errors and the index of
  /// the given filter (-1 if the filter is not active)
  ///
  ({PlayerErrors error, int index}) isFilterActive(int filterType) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.Int> id = calloc(ffi.sizeOf<ffi.Int>());
    final e = _isFilterActive(filterType, id);
    final ret = (error: PlayerErrors.values[e], index: id.value);
    calloc.free(id);
    return ret;
  }

  late final _isFilterActivePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Int>)>>(
      'isFilterActive');
  late final _isFilterActive =
      _isFilterActivePtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Get parameters names of the given filter.
  ///
  /// [filterType] filter to get param names
  /// Returns [PlayerErrors.noError] if no errors and the list of param names
  ///
  ({PlayerErrors error, List<String> names}) getFilterParamNames(
      int filterType) {
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.Int> paramsCount = calloc(ffi.sizeOf<ffi.Int>());
    // ignore: omit_local_variable_types
    final ffi.Pointer<ffi.Pointer<ffi.Char>> names =
        calloc(ffi.sizeOf<ffi.Char>() * 30);

    final e = _getFilterParamNames(
      filterType,
      paramsCount,
      names,
    );
    final pNames = <String>[];
    for (var i = 0; i < paramsCount.value; i++) {
      pNames.add(names[i].cast<Utf8>().toDartString());
    }
    final ret = (error: PlayerErrors.values[e], names: pNames);
    calloc.free(paramsCount);
    for (var i = 0; i < pNames.length; i++) {
      calloc.free(names[i]);
    }
    calloc.free(names);
    return ret;
  }

  late final _getFilterParamNamesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getFilterParamNames');
  late final _getFilterParamNames = _getFilterParamNamesPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Add the filter [filterType].
  ///
  /// [filterType] filter to add
  /// Returns [PlayerErrors.noError] if no errors
  ///
  int addGlobalFilter(int filterType) {
    return _addGlobalFilter(filterType);
  }

  late final _addGlobalFilterPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'addGlobalFilter');
  late final _addGlobalFilter =
      _addGlobalFilterPtr.asFunction<int Function(int)>();

  /// Remove the filter [filterType].
  ///
  /// [filterType] filter to remove
  /// Returns [PlayerErrors.noError] if no errors
  ///
  int removeGlobalFilter(int filterType) {
    return _removeGlobalFilter(filterType);
  }

  late final _removeGlobalFilterPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'removeGlobalFilter');
  late final _removeGlobalFilter =
      _removeGlobalFilterPtr.asFunction<int Function(int)>();

  /// Set the effect parameter with id [attributeId]
  /// of [filterType] with [value] value.
  ///
  /// [filterType] filter to modify a param
  /// Returns [PlayerErrors.noError] if no errors
  ///
  int setFxParams(int filterType, int attributeId, double value) {
    return _setFxParams(filterType, attributeId, value);
  }

  late final _setFxParamsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int, ffi.Float)>>(
      'setFxParams');
  late final _setFxParams =
      _setFxParamsPtr.asFunction<int Function(int, int, double)>();

  /// Get the effect parameter with id [attributeId] of [filterType].
  ///
  /// [filterType] filter to modify a param
  /// Returns the value of param
  ///
  double getFxParams(int filterType, int attributeId) {
    return _getFxParams(filterType, attributeId);
  }

  late final _getFxParamsPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Int32, ffi.Int)>>(
          'getFxParams');
  late final _getFxParams =
      _getFxParamsPtr.asFunction<double Function(int, int)>();

  /////////////////////////////////////////
  /// 3D audio methods
  /////////////////////////////////////////

  /// play3d() is the 3d version of the play() call.
  ///
  /// Returns the handle of the sound, 0 if error
  int play3d(
    int soundHash,
    double posX,
    double posY,
    double posZ, {
    double velX = 0,
    double velY = 0,
    double velZ = 0,
    double volume = 1,
    bool paused = false,
  }) {
    return _play3d(
      soundHash,
      posX,
      posY,
      posZ,
      velX,
      velY,
      velZ,
      volume,
      paused ? 1 : 0,
    );
  }

  late final _play3dPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Int,
          )>>('play3d');
  late final _play3d = _play3dPtr.asFunction<
      int Function(
        int,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        int,
      )>();

  /// Since SoLoud has no knowledge of the scale of your coordinates,
  /// you may need to adjust the speed of sound for these effects
  /// to work correctly. The default value is 343, which assumes
  /// that your world coordinates are in meters (where 1 unit is 1 meter),
  /// and that the environment is dry air at around 20 degrees Celsius.
  ///
  void set3dSoundSpeed(double speed) {
    return _set3dSoundSpeed(speed);
  }

  late final _set3dSoundSpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
    'set3dSoundSpeed',
  );
  late final _set3dSoundSpeed =
      _set3dSoundSpeedPtr.asFunction<void Function(double)>();

  /// Get the sound speed.
  ///
  double get3dSoundSpeed() {
    return _get3dSoundSpeed();
  }

  late final _get3dSoundSpeedPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function()>>('get3dSoundSpeed');
  late final _get3dSoundSpeed =
      _get3dSoundSpeedPtr.asFunction<double Function()>();

  /// You can set the position, at-vector, up-vector and velocity
  /// parameters of the 3d audio listener with one call
  ///
  void set3dListenerParameters(
    double posX,
    double posY,
    double posZ,
    double atX,
    double atY,
    double atZ,
    double upX,
    double upY,
    double upZ,
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dListenerParameters(
      posX,
      posY,
      posZ,
      atX,
      atY,
      atZ,
      upX,
      upY,
      upZ,
      velocityX,
      velocityY,
      velocityZ,
    );
  }

  late final _set3dListenerParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerParameters');
  late final _set3dListenerParameters = _set3dListenerParametersPtr.asFunction<
      void Function(
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
        double,
      )>();

  /// You can set the position parameter of the 3d audio listener
  ///
  void set3dListenerPosition(double posX, double posY, double posZ) {
    return _set3dListenerPosition(posX, posY, posZ);
  }

  late final _set3dListenerPositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerPosition');
  late final _set3dListenerPosition = _set3dListenerPositionPtr
      .asFunction<void Function(double, double, double)>();

  /// You can set the "at" vector parameter of the 3d audio listener.
  ///
  void set3dListenerAt(double atX, double atY, double atZ) {
    return _set3dListenerAt(atX, atY, atZ);
  }

  late final _set3dListenerAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerAt');
  late final _set3dListenerAt =
      _set3dListenerAtPtr.asFunction<void Function(double, double, double)>();

  /// You can set the "up" vector parameter of the 3d audio listener.
  ///
  void set3dListenerUp(double upX, double upY, double upZ) {
    return _set3dListenerUp(upX, upY, upZ);
  }

  late final _set3dListenerUpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerUp');
  late final _set3dListenerUp =
      _set3dListenerUpPtr.asFunction<void Function(double, double, double)>();

  /// You can set the listener's velocity vector parameter.
  ///
  void set3dListenerVelocity(
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dListenerVelocity(velocityX, velocityY, velocityZ);
  }

  late final _set3dListenerVelocityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dListenerVelocity');
  late final _set3dListenerVelocity = _set3dListenerVelocityPtr
      .asFunction<void Function(double, double, double)>();

  /// You can set the position and velocity parameters of a live
  /// 3d audio source with one call.
  ///
  void set3dSourceParameters(
    int handle,
    double posX,
    double posY,
    double posZ,
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dSourceParameters(
      handle,
      posX,
      posY,
      posZ,
      velocityX,
      velocityY,
      velocityZ,
    );
  }

  late final _set3dSourceParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourceParameters');
  late final _set3dSourceParameters = _set3dSourceParametersPtr.asFunction<
      void Function(int, double, double, double, double, double, double)>();

  /// You can set the position parameters of a live 3d audio source
  ///
  void set3dSourcePosition(int handle, double posX, double posY, double posZ) {
    return _set3dSourcePosition(handle, posX, posY, posZ);
  }

  late final _set3dSourcePositionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourcePosition');
  late final _set3dSourcePosition = _set3dSourcePositionPtr
      .asFunction<void Function(int, double, double, double)>();

  /// You can set the velocity parameters of a live 3d audio source
  ///
  void set3dSourceVelocity(
    int handle,
    double velocityX,
    double velocityY,
    double velocityZ,
  ) {
    return _set3dSourceVelocity(handle, velocityX, velocityY, velocityZ);
  }

  late final _set3dSourceVelocityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourceVelocity');
  late final _set3dSourceVelocity = _set3dSourceVelocityPtr
      .asFunction<void Function(int, double, double, double)>();

  /// You can set the minimum and maximum distance parameters
  /// of a live 3d audio source
  ///
  void set3dSourceMinMaxDistance(
    int handle,
    double minDistance,
    double maxDistance,
  ) {
    return _set3dSourceMinMaxDistance(handle, minDistance, maxDistance);
  }

  late final _set3dSourceMinMaxDistancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.Float,
            ffi.Float,
          )>>('set3dSourceMinMaxDistance');
  late final _set3dSourceMinMaxDistance = _set3dSourceMinMaxDistancePtr
      .asFunction<void Function(int, double, double)>();

  /// You can change the attenuation model and rolloff factor parameters of
  /// a live 3d audio source.
  ///
  /// NO_ATTENUATION 	      No attenuation
  /// INVERSE_DISTANCE 	    Inverse distance attenuation model
  /// LINEAR_DISTANCE 	    Linear distance attenuation model
  /// EXPONENTIAL_DISTANCE 	Exponential distance attenuation model
  ///
  /// see https://solhsa.com/soloud/concepts3d.html
  ///
  void set3dSourceAttenuation(
    int handle,
    int attenuationModel,
    double attenuationRolloffFactor,
  ) {
    return _set3dSourceAttenuation(
      handle,
      attenuationModel,
      attenuationRolloffFactor,
    );
  }

  late final _set3dSourceAttenuationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
            ffi.UnsignedInt,
            ffi.UnsignedInt,
            ffi.Float,
          )>>('set3dSourceAttenuation');
  late final _set3dSourceAttenuation =
      _set3dSourceAttenuationPtr.asFunction<void Function(int, int, double)>();

  /// You can change the doppler factor of a live 3d audio source
  ///
  void set3dSourceDopplerFactor(int handle, double dopplerFactor) {
    return _set3dSourceDopplerFactor(handle, dopplerFactor);
  }

  late final _set3dSourceDopplerFactorPtr = _lookup<
      ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt, ffi.Float)>>(
    'set3dSourceDopplerFactor',
  );
  late final _set3dSourceDopplerFactor =
      _set3dSourceDopplerFactorPtr.asFunction<void Function(int, double)>();

  /// internal test. Does nothing now
  ///
  void test() {
    return _test();
  }

  late final _testPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('test');
  late final _test = _testPtr.asFunction<void Function()>();
}
